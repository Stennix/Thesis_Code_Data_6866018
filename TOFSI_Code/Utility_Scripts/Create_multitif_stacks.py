"""
Script to collapse z-focal plane (tiff)-images into multi-tiff images.
Fully generated by AI-promts, use with caution.
Might require alterations based on your image specifications.
Stores the output in your input folder by default.
Assumes tiff images are in the correct order in your folder.




Every N images (default 12) become one TIFF stack saved in a "stacks" subfolder.

Changes from your previous version:
- Writes each stack in a single call with a pre-built array shaped (Z, Y, X[, C]).
- Adds TIFF metadata "axes" = "ZYX" or "ZYXC" so readers treat pages as Z.
- Preserves color; auto-promotes grayscale to RGB if a group mixes modes.
- Validates that all frames in a stack share width/height/bit-depth.

How to use in Spyder:
1) Edit the CONFIG block (FOLDER, etc.)
2) Run.

CLI:
    python make_tiff_stacks.py /path/to/folder --group-size 12 --ext jpg png tif tiff --include-incomplete
"""

from __future__ import annotations
from pathlib import Path
from typing import List, Tuple
import re
import sys

# =========================
# ======== CONFIG =========
FOLDER = r"YOUR_IMAGE_FOLDER"
GROUP_SIZE = 12 #number of z-focus levels
EXTENSIONS = ["tif", "tiff", "png", "jpg", "jpeg", "bmp"]
OUTPUT_SUBFOLDER = "stacks"
OUTPUT_PREFIX = "stack_"
START_INDEX = 1
ZERO_PAD = 3
INCLUDE_INCOMPLETE = True
COMPRESSION = "none"  # "none","zlib","lzw","jpeg","jpeg2000","packbits"
OUTPUT_EXT = ".tif"  # choose ".tif" or ".tiff"
# ======== CONFIG =========
# =========================


def _lazy_imports():
    """Import heavy deps only when needed."""
    global tifffile, iio, np
    import tifffile
    import imageio.v3 as iio
    import numpy as np
    return tifffile, iio, np


def natural_key(s: str):
    """Natural sort key (digit runs are compared as integers)."""
    _nsre = re.compile(r'(\d+)')
    return [int(text) if text.isdigit() else text.lower() for text in _nsre.split(s)]


def list_images(folder: Path, exts: List[str]) -> List[Path]:
    """List image files in a folder with given extensions, natural-sorted."""
    exts = {f".{e.lower().lstrip('.')}" for e in exts}
    files = [
        p for p in folder.iterdir()
        if p.is_file() and not p.name.startswith('.') and p.suffix.lower() in exts
    ]
    files.sort(key=lambda p: natural_key(p.name))
    return files


def chunks(lst: List[Path], n: int):
    """Yield successive n-sized chunks from lst."""
    for i in range(0, len(lst), n):
        yield lst[i:i + n]


def _is_grayscale(arr) -> bool:
    """True if image is 2D or last dim == 1 (e.g., (H,W) or (H,W,1))."""
    return (arr.ndim == 2) or (arr.ndim == 3 and arr.shape[-1] == 1)


def _promote_to_rgb(arr, np):
    """Convert grayscale to RGB by stacking 3 identical channels."""
    if arr.ndim == 2:
        arr = arr[..., None]
    if arr.shape[-1] == 1:
        arr = np.repeat(arr, 3, axis=-1)
    return arr


def _ensure_consistent_group(shapes: List[Tuple[int, ...]], dtypes: List[str]):
    """
    Validate consistent H,W and dtype across a group.
    Returns (height, width, channels or None).
    """
    # Height/Width consistent?
    hw = {(s[-2], s[-1]) if len(s) >= 2 else None for s in shapes}  # careful: imageio loads as (H,W[,C])
    if None in hw or len(hw) != 1:
        raise ValueError(f"Inconsistent image sizes in group: {shapes}")
    (H, W) = next(iter(hw))

    # dtype consistent?
    if len(set(dtypes)) != 1:
        raise ValueError(f"Inconsistent dtypes in group: {set(dtypes)}")

    # channels consistent? (we'll allow mix gray/RGB and promote gray â†’ RGB)
    chans = []
    for s in shapes:
        c = None
        if len(s) == 3:
            c = s[-1]
        chans.append(c)
    # If any is 3/4, we'll standardize to 3 (RGB)
    if any(c in (3, 4) for c in chans):
        C = 3
    else:
        C = None  # all grayscale

    return H, W, C


def write_stack(images: List[Path], out_path: Path, compression: str | None):
    """
    Write a true Z-stack in one call with explicit axes metadata:
      - grayscale: (Z, Y, X), metadata={"axes": "ZYX"}
      - color:     (Z, Y, X, 3), metadata={"axes": "ZYXC"}, photometric='rgb'
    """
    tifffile, iio, np = _lazy_imports()
    out_path.parent.mkdir(parents=True, exist_ok=True)

    # Read all frames
    frames = []
    shapes = []
    dtypes = []
    for p in images:
        arr = iio.imread(p)
        frames.append(arr)
        shapes.append(arr.shape)
        dtypes.append(str(arr.dtype))

    # Validate and normalize
    H, W, C = _ensure_consistent_group(shapes, dtypes)

    norm_frames = []
    for arr in frames:
        if C is None:
            # grayscale stack: ensure 2D (H,W)
            if arr.ndim == 3 and arr.shape[-1] == 1:
                arr = arr[..., 0]
            elif arr.ndim == 3 and arr.shape[-1] in (3, 4):
                # shouldn't happen because C would then be 3; but guard anyway
                arr = iio.core.asarray(arr)  # no-op
                arr = arr[..., :3]
                arr = arr.mean(axis=-1).astype(arr.dtype)
        else:
            # color stack: ensure RGB
            if _is_grayscale(arr):
                arr = _promote_to_rgb(arr, np)
            if arr.shape[-1] == 4:  # RGBA -> RGB (drop alpha)
                arr = arr[..., :3]
        norm_frames.append(np.ascontiguousarray(arr))

    # Build (Z, Y, X[, C]) array
    if C is None:
        ZYX = np.stack(norm_frames, axis=0)  # (Z,H,W)
        axes = "ZYX"
        kwargs = dict(metadata={"axes": axes})
    else:
        ZYXC = np.stack(norm_frames, axis=0)  # (Z,H,W,3)
        axes = "ZYXC"
        kwargs = dict(metadata={"axes": axes}, photometric="rgb", planarconfig="contig")

    # Write once. Avoid imagej=True to keep axes exactly as declared.
    data = ZYX if C is None else ZYXC
    tifffile.imwrite(
        out_path,
        data,
        compression=(compression if compression else None),
        **kwargs
    )


def run(
    folder: Path,
    group_size: int = 12,
    extensions: List[str] | None = None,
    output_subfolder: str = "stacks",
    prefix: str = "stack_",
    start_index: int = 1,
    zero_pad: int = 3,
    include_incomplete: bool = True,
    compression: str = "none",
    output_ext: str = ".tif",
):
    """Core runner function (works for both Spyder and CLI)."""
    if extensions is None:
        extensions = ["tif", "tiff", "png", "jpg", "jpeg", "bmp"]

    folder = folder.expanduser().resolve()
    if not folder.exists() or not folder.is_dir():
        raise FileNotFoundError(f"Folder does not exist or is not a directory: {folder}")

    images = list_images(folder, extensions)
    if not images:
        print("No images found matching the given extensions.", file=sys.stderr)
        return

    group_list = list(chunks(images, group_size))
    if not include_incomplete and group_list and len(group_list[-1]) < group_size:
        group_list = group_list[:-1]

    if not group_list:
        print("No complete groups to write (consider include_incomplete=True).", file=sys.stderr)
        return

    outdir = folder / output_subfolder
    outdir.mkdir(exist_ok=True)

    comp = None if compression == "none" else compression

    # Warn about lossy/bit-depth caveats
    if compression in ("jpeg", "jpeg2000"):
        print("[WARN] Using lossy compression; pixel values may change.")
    if compression == "jpeg":
        print("[WARN] JPEG typically supports 8-bit only; 16-bit images may be downcast by some viewers.")

    count_written = 0
    idx = start_index
    for g in group_list:
        out_name = f"{prefix}{str(idx).zfill(zero_pad)}{output_ext}"
        out_path = outdir / out_name
        write_stack(g, out_path, compression=comp)
        print(f"Wrote {out_path} ({len(g)} slices)")
        idx += 1
        count_written += 1

    print(f"Done. Wrote {count_written} stack(s) to: {outdir}")


def _parse_args(argv: list[str]):
    """Parse CLI arguments (used when running from a terminal)."""
    import argparse
    parser = argparse.ArgumentParser(description="Create multi-page TIFF stacks from images in a folder.")
    parser.add_argument("folder", type=str, help="Path to the folder containing images.")
    parser.add_argument("--group-size", type=int, default=12, help="Number of images per stack (default: 12).")
    parser.add_argument("--ext", nargs="+", default=["tif","tiff","png","jpg","jpeg","bmp"],
                        help="Image extensions to include (default: tif tiff png jpg jpeg bmp).")
    incl = parser.add_mutually_exclusive_group()
    incl.add_argument("--include-incomplete", action="store_true", default=True,
                      help="Include final group even if fewer than group-size (default).")
    incl.add_argument("--drop-incomplete", action="store_true", help="Drop final group if incomplete.")
    parser.add_argument("--output-subfolder", default="stacks",
                        help='Subfolder inside "folder" to write stacks (default: "stacks").')
    parser.add_argument("--prefix", default="stack_", help='Output filename prefix (default: "stack_").')
    parser.add_argument("--start-index", type=int, default=1, help="Starting index for stacks (default: 1).")
    parser.add_argument("--zero-pad", type=int, default=3, help="Zero-padding width for stack index (default: 3 -> 001).")
    parser.add_argument("--compression", choices=["none","zlib","lzw","jpeg","jpeg2000","packbits"],
                        default="none",
                        help="TIFF compression (default: none). Note: lossy options may change pixel values.")
    parser.add_argument("--output-ext", choices=[".tif",".tiff"], default=".tif",
                        help="File extension for stacks (default: .tif).")
    args = parser.parse_args(argv)
    return args


if __name__ == "__main__":
    # If arguments are provided -> CLI mode.
    # If not -> Spyder mode using CONFIG above.
    if len(sys.argv) > 1:
        a = _parse_args(sys.argv[1:])
        run(
            folder=Path(a.folder),
            group_size=a.group_size,
            extensions=a.ext,
            output_subfolder=a.output_subfolder,
            prefix=a.prefix,
            start_index=a.start_index,
            zero_pad=a.zero_pad,
            include_incomplete=(not a.drop_incomplete),
            compression=a.compression,
            output_ext=a.output_ext,
        )
    else:
        # Spyder mode with CONFIG
        run(
            folder=Path(FOLDER),
            group_size=GROUP_SIZE,
            extensions=EXTENSIONS,
            output_subfolder=OUTPUT_SUBFOLDER,
            prefix=OUTPUT_PREFIX,
            start_index=START_INDEX,
            zero_pad=ZERO_PAD,
            include_incomplete=INCLUDE_INCOMPLETE,
            compression=COMPRESSION,
            output_ext=OUTPUT_EXT,
        )
